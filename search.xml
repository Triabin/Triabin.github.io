<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第3章数组</title>
      <link href="/2020/08/02/%E7%AC%AC3%E7%AB%A0%E6%95%B0%E7%BB%84/"/>
      <url>/2020/08/02/%E7%AC%AC3%E7%AB%A0%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="包名命名规范"><a href="#包名命名规范" class="headerlink" title="包名命名规范"></a>包名命名规范</h1><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802213450.png" alt="01PackageNameingNotations"></p><ul><li>前面为域名倒着写，最后（contact）则体现不同的功能</li></ul><h1 id="数组的概述"><a href="#数组的概述" class="headerlink" title="数组的概述"></a>数组的概述</h1><ul><li>数组（Array），是多个相同数据类型按一定顺序排列的集合，并使用一个名字命名，通过编号的方式对这些数据进行统一管理。</li></ul><h2 id="数组的常见概念"><a href="#数组的常见概念" class="headerlink" title="数组的常见概念"></a>数组的常见概念</h2><ol><li>数组名</li><li>标（或索引）</li><li>元素</li><li>数组的长度：元素的个数</li></ol><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>数组是有序排列的；</li><li>数组属于引用数据类型，但是数组的元素既可以是基本数据类型，也可以是引用数据类型；</li><li>创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址；</li><li>数组的长度一旦确定，就不能修改；</li><li>可以通过下标（或索引）的方式调用指定位置的元素，速度很快。</li></ol><h2 id="数组的分类"><a href="#数组的分类" class="headerlink" title="数组的分类"></a>数组的分类</h2><ol><li>按照维数：一维数组、二维数组……</li><li>按照数组元素类型分类：基本数据类型元素的素组、引用数据类型元素的数组。</li></ol><h1 id="了解"><a href="#了解" class="headerlink" title="了解"></a>了解</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol><li><p>数据与数据之间的逻辑关系：集合、一对一、一对多、多对多</p></li><li><p>数据的存储结构：</p><ul><li>线性表：顺序表（比如：数组）、链表、栈、队列</li></ul><ul><li>树形结构：二叉树</li><li>图形结构：</li></ul></li></ol><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ol><li>排序算法</li><li>搜（检索）索算法</li></ol><h1 id="一维数组的使用"><a href="#一维数组的使用" class="headerlink" title="一维数组的使用"></a>一维数组的使用</h1><h2 id="一维数组的声明和初始化"><a href="#一维数组的声明和初始化" class="headerlink" title="一维数组的声明和初始化"></a>一维数组的声明和初始化</h2><ol><li>声明：<code>int[] ins;</code></li><li>静态初始化：数组的初始化和数组的赋值操作同时进行。</li></ol><ul><li><code>int ids = new int[]&#123;1001,1002,1003,1004&#125;;</code></li></ul><ol start="3"><li>动态初始化：数组的初始化和数组的赋值操作分开进行</li></ol><ul><li><code>String[] names = new String[5];</code></li></ul><ol start="4"><li>错误写法</li></ol><ul><li><code>int[] arr1 = new int[];</code></li><li><code>int[5] arr2 = new int[5];</code></li><li><code>int [] arr3 = new int[3]&#123;1,2,3&#125;;</code></li></ul><ol start="5"><li>总结：数组一旦初始化完成，其长度就确定了。</li></ol><h3 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h3><ol><li>如何调用数组指定函数指定位置的函数</li></ol><ul><li>通过索引（角标）的方式调用，索引（角标）从0开始，直到数组的长度-1结束</li></ul><ol start="2"><li>如何获取数组的长度</li></ol><ul><li>属性：length</li><li>使用：<code>names.length</code></li></ul><ol start="3"><li>遍历数组</li></ol><ul><li><code>for(int i = 0; i &lt; names.length; i++)&#123;&#125;</code></li></ul><h3 id="数组元素的默认初始化值"><a href="#数组元素的默认初始化值" class="headerlink" title="数组元素的默认初始化值"></a>数组元素的默认初始化值</h3><ol><li>数组元素是整形：0</li><li>数组元素浮点型：0.0</li><li>数组元素是char型：0（NUT）或’\u0000’（ASCII码为0的值）</li><li>数组元素是boolean型：false</li><li>数组元素是引用数据类型：null</li></ol><h3 id="数组的内存解析"><a href="#数组的内存解析" class="headerlink" title="数组的内存解析"></a>数组的内存解析</h3><ol><li>栈（stack）：存放局部变量</li><li>堆（heap)：存放new出来的结构（对象数组）</li><li>方法区</li></ol><ul><li>常量池</li><li>静态域</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802215212.png" alt="02ArrayMemoryParse"></p><ul><li>栈中的所有地址为Java虚拟机计算出来的哈希地址，并非真正的内存地址</li></ul><h1 id="多维数组的使用"><a href="#多维数组的使用" class="headerlink" title="多维数组的使用"></a>多维数组的使用</h1><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><ol><li>理解：对于二维数组的理解，可以看成是一维数组array1的元素而存在。<font color="red">从数组底层的运行机制来看，其实没有多维数组。</font></li><li>二维数组的使用</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;;<span class="comment">//静态初始化</span></span><br><span class="line">String[][] arr2 = <span class="keyword">new</span> String[<span class="number">3</span>][<span class="number">2</span>];<span class="comment">//动态初始化1</span></span><br><span class="line">String[][] arr3 = <span class="keyword">new</span> String[<span class="number">3</span>][];<span class="comment">//动态初始化2</span></span><br></pre></td></tr></table></figure><ul><li>错误情况</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[][] arr4 = <span class="keyword">new</span> String[][<span class="number">4</span>];</span><br><span class="line">String[<span class="number">4</span>][<span class="number">3</span>] arr5 = <span class="keyword">new</span> String[][];</span><br><span class="line"><span class="keyword">int</span>[][] arr6 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">3</span>]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><ul><li>Tips：中括号（[]）的位置可以放在类名或者变量名后面；或者类名后面放一个，变量名后面放一个（二维数组）。</li><li>类型推断：<code>int[][] arr7 = &#123;&#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;6, 7, 8&#125;&#125;;//省略new int[][]</code></li></ul><h3 id="数组的基本操作-1"><a href="#数组的基本操作-1" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h3><ol><li>如何调用数组指定位置的函数</li></ol><ul><li><code>arry[i][j]; //第i行第j列的元素</code></li></ul><ol start="2"><li>如何获取数组长度</li></ol><ul><li><code>arr4.length;</code></li><li><code>arr4[0].length;</code></li></ul><ol start="3"><li>如何遍历数组</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; a &lt;= arr4.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= arr4[i].length)&#123;</span><br><span class="line">        <span class="comment">//执行语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组元素的默认初始化值-1"><a href="#数组元素的默认初始化值-1" class="headerlink" title="数组元素的默认初始化值"></a>数组元素的默认初始化值</h3><ol><li>规定：二维数组分为外层数组的元素和内层数组的元素</li></ol><p><code>int[][] arr = new int[4][3];</code></p><ul><li><p>外层元素：arr[0]，arr[1]等；</p></li><li><p>内层元素：arr[0][0]，arr[1][2]等；</p></li><li><p>初始化方式一：<code>int[][] arr = new int[4][3];</code></p><ul><li>外层元素的初始化值为：地址值</li><li>外侧元素的初始化值：与一维数组初始化情况相同</li></ul></li><li><p>初始化方式二：<code>int[][] arr = new int[4][];</code></p></li><li><ul><li>外层元素的初始化值为：null</li><li>内层元素的初始化值为：不能调用，否则报错</li></ul></li></ul><h3 id="内存解析"><a href="#内存解析" class="headerlink" title="内存解析"></a>内存解析</h3><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802223836.png" alt="02ArrayMemoryParse02"></p><h1 id="数组中涉及到的常见算法"><a href="#数组中涉及到的常见算法" class="headerlink" title="数组中涉及到的常见算法"></a>数组中涉及到的常见算法</h1><ol><li><p>数组元素的赋值（杨辉三角、回形书等）（<font color="red">面试常考</font>）</p></li><li><p>求数值型数组中元素的最大值、最小值、平均数、总数等</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dawnlee.arrayex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 求数值型数组中元素的最大值、最小值、平均数、总和等</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-7-27        22:14:07</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> avg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++) &#123;</span><br><span class="line">            array[i] = (<span class="keyword">int</span>)(Math.random() * (<span class="number">99</span> - <span class="number">10</span> + <span class="number">1</span>) + <span class="number">10</span>);</span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(array[i] &gt; maxValue) &#123;</span><br><span class="line">                maxValue = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            sum += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        minValue = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &lt; minValue) &#123;</span><br><span class="line">                minValue = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        avg = sum / array.length;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n最大值为：&quot;</span> + maxValue);</span><br><span class="line">        System.out.println(<span class="string">&quot;最小值为：&quot;</span> + minValue);</span><br><span class="line">        System.out.println(<span class="string">&quot;平均数为：&quot;</span> + avg);</span><br><span class="line">        System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>数组的复制、反转、查找（线性查找、<font color="red">二分法查找</font>）（面试会考）</li></ol><ul><li><p>复制：通过遍历元素的方式进行复制操作，赋值只能使得新数组值相同一块内存区域，修改其中一个，原数组就得一起改变，相当于Linux中的硬链接</p></li><li><p>反转：通过中间变量实现反转</p></li><li><p>查找</p><ul><li>线性查找</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String dest = <span class="string">&quot;BB&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> isFind = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dest.equals(arr[i]))&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找到了指定元素，位置为：&quot;</span> + i);</span><br><span class="line">        isFind = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isFind == <span class="keyword">false</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;没找到！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二分法查找</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有要查找的数组必须有序</span></span><br><span class="line"><span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">98</span>,-<span class="number">34</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">54</span>,<span class="number">66</span>,<span class="number">79</span>,<span class="number">105</span>,<span class="number">210</span>,<span class="number">333</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dest1 = -<span class="number">34</span>;</span><br><span class="line"><span class="keyword">int</span> head = <span class="number">0</span>;<span class="comment">//初始首索引</span></span><br><span class="line"><span class="keyword">int</span> end = arr2.length - <span class="number">1</span>;<span class="comment">//初始末索引</span></span><br><span class="line"><span class="keyword">boolean</span> isFind = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(head &lt;= end)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (head + end)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(dest1 == arr2[mid])&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找到了指定的元素，位置为：&quot;</span> + mid);</span><br><span class="line">        isFind = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr2[mid] &gt; dest1)&#123;</span><br><span class="line">        end = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        head = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isFind == <span class="keyword">false</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;很遗憾，没有找到！&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li>数组元素的排序算法（<font color="red">面试最常考</font>）</li></ol><ul><li>排序：假设含有n个记录的序列为(R1, R2,…, Rn)，其相应的关键字序列为(K1, K2,…, Kn)。将这些记录重新排序为(Ri1, Ri2,…, Rin)，使得相应的关键字满足条件Ki1 &lt;= Ki2 &lt;=…&lt;= Kin，这样的一种操作成为排序。<ul><li>通常来说，排序的目的是快速查找。</li></ul></li><li>衡量排序算法的优劣<ul><li>时间复杂度：分析关键字的比较次数和记录的移动次数。</li><li>空间复杂度：分析排序算法中徐需要多少辅助内存。</li><li>稳定性：若两个记录A和B的关键字值相等，但排序后A、B先后次序保持不变，则称这种排序算法是稳定的。</li></ul></li></ul><h2 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h2><ol><li>内部排序：整个排序过程不需要借助外部存储器（如磁盘等），所有排序操作都在内存中完成。</li></ol><ul><li><p>十大内部排序算法（和具体语言无关），前八种较常用。</p><ul><li><p>选择排序：</p><p>①直接选择排序；</p><p>②堆排序。</p></li><li><p>交换排序</p><p>③冒泡排序</p><ul><li>介绍：冒泡排序的原理很简单，它重复地走访要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。</li><li>排序思想：比较相邻的元素，如果第一个比第二个大（升序），就交换它们两个；对每一对相邻元素做同样的工作，从开始的第一对到结尾的最后一对，这步做完后，最后元素回事最大的数；针对所有的元素重复上述步骤，除了最后一个；持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dawnlee.arrayex;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 数组冒泡排序的实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-7-28        14:24:38</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">43</span>,<span class="number">32</span>,<span class="number">76</span>,-<span class="number">98</span>,<span class="number">0</span>,<span class="number">64</span>,<span class="number">33</span>,-<span class="number">21</span>,<span class="number">32</span>,<span class="number">99</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; arr.length - <span class="number">1</span> - i;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>④快速排序</p><ul><li>介绍：快速排序通常明显比同为O（nlogn）的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中经常看到快排的影子。快速排列（Quick Sort）有图灵奖获得者Tony Hoare发明，被列为20世纪十大算法之一，是迄今为止所有内排序算中速度最快的一种。快速排序的时间复杂度为O（nlog(n)）。</li><li>排序思想：从数列种挑出一个元素，称为“基准”（pivot）；重新排序数列，所有元素比基准值小的放在基准值前面，比基准值大的放在基准值后面（相同的数可以到任一边）。在这个分区结束后，该基准就处于数列的中间位置。这个称为分区（partition）操作；递归地（recursive）把小于基准值的子数列和大于基准值的子数列排序；递归的最底部情形是数列的大小事0或1，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为每次迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</li></ul></li></ul></li><li><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802230020.png" alt="03QuickSort"></p><ul><li><p>插入排序</p><p>⑤直接插入排序</p><p>⑥折半插入排序</p><p>⑦Shell排序</p></li><li><p>⑧归并排序</p></li><li><p>⑨桶式排序</p></li><li><p>⑩基数排序</p></li></ul></li></ul><ol start="2"><li>外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助外部存储器（如磁盘等）。外部排序最常见的是多路归并排序。可以认为外部排序是由多个内部排序组成。</li></ol><h2 id="各种排序算法的比较"><a href="#各种排序算法的比较" class="headerlink" title="各种排序算法的比较"></a>各种排序算法的比较</h2><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802230754.png" alt="04SortComparsion"></p><ol><li>从平均时间而言：快速排序最佳，但在最坏的情况下，时间性能不如堆排序和归并排序。</li><li>从算法简单性看：由于直接选择排序、直接插入排序和冒泡排序的算法比较简单，将其认为是简单算法。对于Shell排序、堆排序、快速排序和归并排序算法，其算法比较复杂，认为是复杂排序。</li><li>从稳定性看：直接插入排序、冒泡排序和归并排序是稳定的；而直接选择排序、快速排序、Shell排序和堆排序是不稳定排序。</li><li>从待排序的记录数n的大小看：n较小时，宜采用简单排序；而n较大时，宜采用改进排序。</li></ol><h2 id="排序算法的选择"><a href="#排序算法的选择" class="headerlink" title="排序算法的选择"></a>排序算法的选择</h2><ol><li><p>若n较小（如n≤50），可采用直接插入或直接选择排序。</p></li><li><ul><li>当记录规模较小时，直接插入排序较好，否则因为直接选择移动的记录数少于直接插入，应选直接选择排序为宜。</li></ul></li><li><p>若文件初始状态基本有序（正序），则应选用直接插入、冒泡或随机的快速排序为宜。</p></li><li><p>若n较大，则应采用时间复杂度为O（nlgn）的排序方法：快速排序、堆排序或归并排序。</p></li></ol><h2 id="算法五大特征"><a href="#算法五大特征" class="headerlink" title="算法五大特征"></a>算法五大特征</h2><table><thead><tr><th align="center">输入(Input)</th><th align="left">有0个或多个输入数据，这些输入必须有清楚的描述和定义</th></tr></thead><tbody><tr><td align="center">输出(Output)</td><td align="left">至少有1个或多个输出结果，不可以没有输出结果</td></tr><tr><td align="center">有穷性(有限性，Finiteness)</td><td align="left">算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成</td></tr><tr><td align="center">确定性(明确性，Definiteness)</td><td align="left">算法中的每一步都有明确的含义，不会出现二义性</td></tr><tr><td align="center">可行性(有效性，Effectiveness)</td><td align="left">算法每一步都是清楚且可行的，能让用户用纸和笔计算出答案</td></tr></tbody></table><ul><li>说明：满足确定性的算法也成为了确定性算法。现在人们也关注更广泛的概念，例如考虑各种非确定性的算法，如并行算法、概率算法等。另外，人们也关注并不要求终止的计算描述，这种描述有时被称为过程（procedure）。</li></ul><h1 id="Arrays工具类的使用"><a href="#Arrays工具类的使用" class="headerlink" title="Arrays工具类的使用"></a>Arrays工具类的使用</h1><ol><li>java.util.Arrays类即为操作数组的工具类，它包含了用来操作数组（比如排序和搜索）的各种方法。</li></ol><table><thead><tr><th align="center">1</th><th>boolean equals(int[] a,int[] b)</th><th>判断两个数组是否相等</th></tr></thead><tbody><tr><td align="center">2</td><td>String toString(int[] a)</td><td>输出数组信息</td></tr><tr><td align="center">3</td><td>String toString(int[] a)</td><td>将指定值填充到数组之中</td></tr><tr><td align="center">4</td><td>void fill(int[] a,int val)</td><td>对数组进行排序</td></tr><tr><td align="center">5</td><td>int binarySearch(int[] a,int key)</td><td>对排序后的数组进行二分法检索指定的值</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dawnlee.arrayex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> java.util.Arrays：操作数组的共工具类，里面定义了很多操作数组的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-7-28        16:56:11</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArraysTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.boolean equals(int[] a,int[] b):判断两个数组是否相等</span></span><br><span class="line">        <span class="keyword">int</span>[] arr1 =  <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr2 =  <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> isEquals = Arrays.equals(arr1,arr2);</span><br><span class="line">        System.out.println(isEquals);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.String toString(int[] a):输出数组信息</span></span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.void fill(int[] a,int val):将指定的值填充到数组中</span></span><br><span class="line">        Arrays.fill(arr1,<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.void sort(int[] a):对数组进行排序</span></span><br><span class="line">        Arrays.sort(arr2);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.int binarySearch(int[] a,int key):对排序后的数组进行二分法检索指定的值</span></span><br><span class="line">        <span class="keyword">int</span>[] arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">98</span>,-<span class="number">34</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">54</span>,<span class="number">66</span>,<span class="number">79</span>,<span class="number">105</span>,<span class="number">210</span>,<span class="number">333</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = Arrays.binarySearch(arr3, <span class="number">333</span>);</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(index);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802232505.png" alt="05RunResult01"></p><h1 id="数组中常见的一异常"><a href="#数组中常见的一异常" class="headerlink" title="数组中常见的一异常"></a>数组中常见的一异常</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dawnlee.arrayex;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 说明数组中的常见异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> DawnLee</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020-7-28        17:27:15</span></span><br><span class="line"><span class="comment"> *1.数组角标越界的异常:ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *2.空指针异常:NullPointerException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数组角标越界的异常</span></span><br><span class="line"><span class="comment">//                int[] arr = new int[] &#123;1,2,3,4,5&#125;;</span></span><br><span class="line"><span class="comment">//                for(int i = 0;i &lt;= arr.length;i++) &#123;</span></span><br><span class="line"><span class="comment">//                        System.out.print(arr[i] + &quot; &quot;);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                System.out.println(arr[-2]);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//空指针异常</span></span><br><span class="line">        <span class="comment">//情况一:</span></span><br><span class="line"><span class="comment">//                int[] arr1 = new int[] &#123;1,2,3&#125;;</span></span><br><span class="line"><span class="comment">//                arr1 = null;</span></span><br><span class="line"><span class="comment">//                System.out.println(arr1[0]);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//情况二:</span></span><br><span class="line"><span class="comment">//                int[][] arr2 = new int[4][];</span></span><br><span class="line"><span class="comment">//                System.out.println(arr2[0][0]);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//情况三:</span></span><br><span class="line"><span class="comment">//                String[] arr3 = new String[] &#123;&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;&#125;;</span></span><br><span class="line"><span class="comment">//                arr3[0] = null;</span></span><br><span class="line"><span class="comment">//                System.out.println(arr3[0].toString());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>数组角标越界异常：ArrayIndexOutOfBoundsException</li></ol><ul><li>情况一</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= arr.length;i++) &#123;</span><br><span class="line">    System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802232903.png" alt="06IndexRunResult1"></p><ul><li>情况二</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(arr[-<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802232959.png" alt="06IndexRunResult2"></p><ol start="2"><li>空指针异常</li></ol><ul><li>情况一</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">arr1 = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(arr1[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802233131.png" alt="07NullRunResult1"></p><ul><li>情况二</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][];</span><br><span class="line">System.out.println(arr2[<span class="number">0</span>][<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802233215.png" alt="07NullRunResult2"></p><ul><li>情况三</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr3 = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>&#125;;</span><br><span class="line">arr3[<span class="number">0</span>] = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(arr3[<span class="number">0</span>].toString());</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802233304.png" alt="07NullRunResult3"></p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章基本语法</title>
      <link href="/2020/08/02/%E7%AC%AC2%E7%AB%A0%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/08/02/%E7%AC%AC2%E7%AB%A0%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="关键字与保留字"><a href="#关键字与保留字" class="headerlink" title="关键字与保留字"></a>关键字与保留字</h1><h2 id="关键字（keyword）"><a href="#关键字（keyword）" class="headerlink" title="关键字（keyword）"></a>关键字（keyword）</h2><ol><li>定义：被Java语言赋予特殊含义，用作专门用途的字符（单词）。</li><li>特点：关键字中所有字母都为小写。</li><li>官方地址：<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts.html</a></li></ol><h2 id="保留字（reserved-word）"><a href="#保留字（reserved-word）" class="headerlink" title="保留字（reserved word）"></a>保留字（reserved word）</h2><ol><li>Java保留字：现有的Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字。</li></ol><ul><li>例：goto、const……</li></ul><h1 id="标识符（Identifier）"><a href="#标识符（Identifier）" class="headerlink" title="标识符（Identifier）"></a>标识符（Identifier）</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ol><li>Java对各种变量、方法和类等要素命名时使用的字符序列称为标识符。</li><li>比如：类名、变量名、方法名、接口名、包名……</li><li>技巧：凡是自己可以取名字的地方都叫标识符。</li></ol><h2 id="定义合法标识符规则（必须遵守）"><a href="#定义合法标识符规则（必须遵守）" class="headerlink" title="定义合法标识符规则（必须遵守）"></a>定义合法标识符规则（<font color="red">必须遵守</font>）</h2><ol><li>由26个英文字母大小写，0-9，_或$组成；</li><li>数字不可开头；</li><li>不可以使用关键字和保留字，但可以包含关键字和保留字；</li><li>Java中严格区分大小写，长度无限制；</li><li>标识符不能包含空格。</li></ol><h2 id="Java中名称命名规范（建议遵守）"><a href="#Java中名称命名规范（建议遵守）" class="headerlink" title="Java中名称命名规范（建议遵守）"></a>Java中名称命名规范（<font color="blue">建议遵守</font>）</h2><ol><li><p>包名：多单词组成时所有字母都小写：xxxyyyzzz；</p></li><li><p>类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz ；</p></li><li><p>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz；</p></li><li><p>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ；</p></li><li><p>注意</p><ul><li><p>注意1：在取名字时，为提高阅读性，要尽量有意义（见名知意）</p></li><li><p>注意2：Java采用unicode字符集，因此标识符也可以使用汉字声明，但不建议使用</p></li></ul></li></ol><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量的概念"><a href="#变量的概念" class="headerlink" title="变量的概念"></a>变量的概念</h2><ol><li>内存中的一个存储区域；</li><li>该区域的数据可在同一类型范围内不断变化；</li><li>变量是程序中最基本的存储单元。包含变量类型（强类型：必须先声明）、变量名和存储的值。</li></ol><ul><li>定义变量的格式：数据类型 变量名 = 变量值<ul><li>例：<code>int myAge = 18;</code></li></ul></li></ul><h2 id="变量的作用"><a href="#变量的作用" class="headerlink" title="变量的作用"></a>变量的作用</h2><ol><li>用于在内存中保存数据。</li></ol><h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><ol><li>Java中每个变量必须先声明，后使用；</li><li>变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了。“一对{}”即为一个作用域；</li><li>同一个作用域内，不能声明两个同名的变量。</li><li>Java定义的数据类型（按数据类型分）：对于每一种数据都定义了明确的具体数据类型（强类型语言），在内存中分配了不同大小的内存空间。</li></ol><ul><li><p>基本数据类型（primitive type）</p><p>(1)数值型</p><ul><li><p>整数类型</p><ul><li>byte<ul><li>占用存储空间：1字节 =  8bit位</li><li>表数范围：-128~127（27），最高位为符号位（0正1负），故为7次方</li></ul></li></ul><ul><li><p>short</p><ul><li>占用存储空间：2字节</li><li>表数范围：-215~215-1</li></ul></li><li><p>int</p><ul><li>占用存储空间：4字节</li><li>表数范围：-231~231-1（约21亿）</li></ul></li><li><p>long</p><ul><li>占用存储空间：8字节</li><li>表数范围：-263~263-1</li></ul></li><li><p>注意</p><ul><li>Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保证Java程序的可移植性</li><li>Java的整型常量默认为int型，声明long型常量须后加‘l’或‘L’</li><li>Java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long         </li></ul></li></ul></li></ul><ul><li><p>浮点类型</p><ul><li><p>单精度float</p><ul><li>占用存储空间：4字节</li><li>表数范围：-3.403E38~3.403E38</li></ul></li><li><p>双精度double</p><ul><li>占用存储空间：8字节</li><li>表数范围：-1.798E308~1.798E308</li></ul></li><li><p>注意：与整数类型类似，Java浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响</p></li><li><p>浮点型常量有两种表示形式</p><ul><li>十进制数形式：如：5.12、512.0f、.512          (必须有小数点）</li><li>科学计数法形式:如：5.12e2、512E2、100E-2</li></ul></li><li><p>float：单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求</p></li><li><p>double：双精度，精度是float的两倍。通常采用此类型</p></li><li><p>Java的浮点型常量默认为double型，声明float型常量，须后加’f’或’F’</p></li><li><p>float表示的数值范围比long还大，是因为它使用科学计数法来计数，但是精度不够</p></li></ul></li></ul><p>(2)字符型</p><ul><li><p>char</p><ul><li>1字符 = 2字节</li><li>声明或定义char型变量，通常使用一对单引号（’’），内部只能写一个字符</li><li>转义字符（例如：换行符\n、制表符\t、unicode编号等）</li></ul></li><li><p>布尔型</p><ul><li>boolean<ul><li>只能取两个值之一：true、false</li><li>常用于判断、循环结构</li><li>boolean类型数据只允许取值true和false，无null</li><li>不可以使用0或非 0 的整数替代false和true，这点和C语言不同</li><li>Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替：true用1表示，false用0表示</li></ul></li></ul></li></ul></li><li><p>引用数据类型（reference type）</p><ul><li>类（class）</li><li>接口（interface）</li><li>数组（[]）</li></ul></li></ul><h1 id="编码方式（了解内容）"><a href="#编码方式（了解内容）" class="headerlink" title="编码方式（了解内容）"></a>编码方式（了解内容）</h1><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><ol><li><p>在计算机内部，所有数据都使用二进制表示。每一个二进制位（bit）有0和1两种状态，因此8个二进制位就可以组合出256种状态，这被称为一个字节（byte）。一个字节一共可以用来表示 256       种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111</p></li><li><p>ASCII码：上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码。ASCII码一共规定了128个字符的编码，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0</p></li><li><p>缺点</p></li></ol><ul><li>不能表示所有字符</li><li>相同的编码表示的字符不一样：比如，130在法语编码中代表了é，在希伯来语编码中却代表(ג)了字母Gimel</li></ul><h2 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h2><ol><li><p>乱码：世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，       就会出现乱码。</p></li><li><p>Unicode：一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一 无二的编码，使用Unicode没有乱码的问题。</p></li><li><p>Unicode的缺点</p></li></ol><ul><li>Unicode只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储</li><li>无法区别 Unicode 和ASCII：计算机无法区分三个字节表示一个符号还是分别表示三个符号。另外，我们知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有 二到三个字节是0，这对于存储空间来说是极大的浪费。</li></ul><h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><ol><li><p>UTF-8是在互联网上使用最广的一种Unicode的实现方式</p></li><li><p>UTF-8是一种变长的编码方式。它可以使用**<font color="red">1-6个字节</font>**表示一个符号，根据不同的符号而变化字节长度</p></li><li><p>UTF-8的编码规则</p></li></ol><ul><li>对于单字节的UTF-8编码，该字节的最高位为0，其余7位用来对字符进行编码（等同于ASCII码）</li><li>对于多字节的UTF-8编码，如果编码包含n个字节，那么第一个字节的前n位为1，第一个字节的第n+1位为0，该字节的剩余各位用来对字符进行编码。在第一个字节之后的所有的字节，都是最高两位为”10”，其余6位用来对字符进行编码</li></ul><ol start="4"><li>tips</li></ol><ul><li>解除转义例：解除换行符：\\n，直接显示“\n”</li></ul><h1 id="基本数据类型之间的运算规则"><a href="#基本数据类型之间的运算规则" class="headerlink" title="基本数据类型之间的运算规则"></a>基本数据类型之间的运算规则</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>这里只讨论7种基本数据类型变量间的运算，不包含boolean类型的。</li></ul><h2 id="自动类型提升"><a href="#自动类型提升" class="headerlink" title="自动类型提升"></a>自动类型提升</h2><ol><li>容量小的类型自动转换为容量大的数据类型。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802210501.png"></p><ul><li>byte、char、short三种类型变量做运算时，结果为int类型，即这三个变量之间的运算结果至少要拿一个int型去接收。原因：可能是防止溢出，并且整形常量默认类型为int型，运算时如果直接加减数字的话编译不通过</li></ul><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><ul><li>自动类型提升的逆运算</li></ul><ol><li><p>需要使用强转符</p></li><li><p>强制类型转换可能导致精度损失</p></li></ol><h2 id="字符串类型：String"><a href="#字符串类型：String" class="headerlink" title="字符串类型：String"></a>字符串类型：String</h2><ol><li><p>String属于引用数据类型;</p></li><li><p>声明String类型变量时，使用一对双引号（””），长度不限（不超过内存空间即可）；</p></li><li><p>定义String类型变量时，双引号之间可以没有内容，但是char类型不可以；</p></li><li><p>String可以和8中基本数据类型变量作运算，且运算只能是连接运算（+），运算结果仍是String类型；</p></li><li><p>将String类型转为int型：<code>int num1 = Integer.parseInt(str1)</code>，而不能用强制转换，强制转换只能在上述7种数据类型之间。</p></li></ol><h1 id="进制（了解内容）"><a href="#进制（了解内容）" class="headerlink" title="进制（了解内容）"></a>进制（了解内容）</h1><ul><li>所有数字在计算机底层都以二进制形式存在</li></ul><h2 id="整数的四种表示方式"><a href="#整数的四种表示方式" class="headerlink" title="整数的四种表示方式"></a>整数的四种表示方式</h2><ol><li>二进制(binary)：0,1 ，满2进1，以0b或0B开头；</li><li>十进制(decimal)：0-9 ，满10进1；</li><li>八进制(octal)：0-7 ，满8进1，以数字0开头表示；</li><li>十六进制(hex)：0-9及A-F，满16进1，以0x或0X开头表示。此处的A-F不区分大小写。如：0x21AF + 1 = 0X21B0。</li></ol><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><ol><li><p>Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位；当是long类型时，二进制默认占64位，第64位是符号位</p></li><li><p>二进制的整数有如下三种形式：</p></li></ol><ul><li><p>原码：直接将一个数值换成二进制数。最高位是符号位。</p></li><li><p>负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。</p></li><li><p>负数的补码：其反码加1。</p></li><li><p>计算机以二进制补码的形式存所有的整数。</p><ul><li>正数的原码、反码、补码都相同</li><li>负数的补码是其反码+1</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802210544.png" alt="02ComputeComplement"></p><h2 id="四种进制之间的转换"><a href="#四种进制之间的转换" class="headerlink" title="四种进制之间的转换"></a>四种进制之间的转换</h2><ul><li>以二进制位媒介来转换</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802210603.png" alt="进制转换"></p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul><li>概念：运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等</li></ul><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802210627.png" alt="04ArithmeticOperator"></p><ol><li>整形数相除后默认结果为整形</li></ol><ul><li>需要精确结果进行运算前需要先进行类型转换（自动转换或者强制类型转换）</li></ul><ol start="2"><li>取模（余）运算（%）</li></ol><ul><li>结果符号与被除（模）数相同</li></ul><ol start="3"><li>自增（减）</li></ol><ul><li>（前）++：先自增1，后运算</li><li>（后）++：先运算，后自增1</li><li>自减（略）</li><li>注意：自增（减）不会改变变量本身数据类型</li></ul><h2 id="赋值运算符（-）"><a href="#赋值运算符（-）" class="headerlink" title="赋值运算符（=）"></a>赋值运算符（=）</h2><ol><li><p>当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理</p></li><li><p>支持连续赋值</p></li></ol><ul><li><code>int i1, j1;</code></li><li><code>i1 = j1 = 10;</code></li></ul><h2 id="比较（关系）运算符"><a href="#比较（关系）运算符" class="headerlink" title="比较（关系）运算符"></a>比较（关系）运算符</h2><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802210647.png" alt="05ComparisionOperator"></p><ol><li><p>比较运算符的运算结果都是boolean型，也就是要么是true，要么false</p></li><li><p>区分“=”和“==”</p></li></ol><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802210705.png" alt="06LogicOperator"></p><ol><li>区分逻辑与（&amp;）和短路与（&amp;&amp;）</li></ol><ul><li>相同点：运算结果相同；党符号左边为true时，都会执行符号右边的内容</li><li>不同点：当左边为false时，&amp;&amp;不会执行符号右边的运算（短路）</li><li>开发中优先使用短路与（&amp;&amp;）</li></ul><ol start="2"><li>区分逻辑或（|）和短路或（||）</li></ol><ul><li>相同点：运算结果相同；当符号右边为false时，二者都会执行符号右边的内容</li><li>不同点：当符号左边为true时，|| 不会执行符号右边的运算（短路）</li><li>开发中优先使用短路或（||）</li></ul><ol start="3"><li><p>逻辑非（!）</p></li><li><p>逻辑异或（^）</p></li></ol><h2 id="位运算符（用得较少）"><a href="#位运算符（用得较少）" class="headerlink" title="位运算符（用得较少）"></a>位运算符（用得较少）</h2><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802210726.png" alt="07BitOperator"></p><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802210745.png" alt="08BitOperatorDetails"></p><ol><li><p>位运算符是直接对整数的二进制进行的运算</p></li><li><p>位运算符操作的都是整形的数据</p></li><li><p>&lt;&lt;：在一定范围内，每向左移n位，相当于*2n</p></li><li><p>&gt;&gt;：在一定范围内，每向右移n位，相当于/2n</p></li></ol><ul><li><p>面试题：如何最高效的计算2*8？</p><ul><li>2 &lt;&lt; 3 或 8 &lt;&lt; 1</li></ul></li><li><p>注意：无&lt;&lt;&lt;</p></li></ul><ol start="5"><li>&amp;、|、^运算</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802210803.png" alt="09AndOrXorOperation"></p><ol start="6"><li>~取反运算</li></ol><ul><li>包括符号位在内取反</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802210825.png" alt="10NotOperation"></p><ol start="7"><li>练习：交换两个变量的值</li></ol><ul><li><p>方法一：定义临时变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = num1;</span><br><span class="line">num1 = num2;</span><br><span class="line">num2 = temp;</span><br></pre></td></tr></table></figure></li><li><p>方法二</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num1 = num1 + num2;</span><br><span class="line">num2 = num1 - num2;</span><br><span class="line">num1 = num1 - num2;</span><br></pre></td></tr></table></figure><ul><li>优点：不用定义临时变量、</li><li>弊端：①相加操作可能超出存储范围； ②有局限性：只能适用于数值类型。</li></ul></li><li><p>方法三：使用位运算符</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num1 = num1 ^ num2;</span><br><span class="line">num2 = num1 ^ num2;</span><br><span class="line">num1 = num1 ^ num2;</span><br></pre></td></tr></table></figure></li></ul><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><ol><li>格式：<img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802210855.png" alt="11TernaryOperation"></li></ol><ul><li>条件表达式的结果为boolean类型</li><li>表达式1和表达式2为<strong>同种类型</strong></li><li>三元运算符可嵌套使用</li></ul><ol start="2"><li>三元运算符与if-else的联系与区别</li></ol><ul><li>三元运算符可简化if-else语句，因此能用三元运算符的地方尽量用三元运算符</li><li>三元运算符要求必须返回一个结果</li><li>if后的代码块可有多个语句</li><li>凡是可以使用三元运算符的地方都可以改写成if-else，反之则不一定行</li></ul><ol start="3"><li>练习：获取3个数中的最大值</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> max1 = (a &gt; b)? a : b;</span><br><span class="line"><span class="keyword">int</span> max2 = (max1 &gt; c)? max1 : c;</span><br></pre></td></tr></table></figure><h2 id="运算符的优先等级"><a href="#运算符的优先等级" class="headerlink" title="运算符的优先等级"></a>运算符的优先等级</h2><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802210916.png" alt="12OperatorPrecedence"></p><ol><li><p>运算符有不同优先级，所谓优先级就是表达式 运算中的运算顺序</p></li><li><p>只有单目运算符、三元运算符、赋值运算符是从右向左运算的</p></li></ol><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><ul><li>流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块</li></ul><h2 id="如何从键盘-控制台获取不同类型的变量：需要使用Scanner类"><a href="#如何从键盘-控制台获取不同类型的变量：需要使用Scanner类" class="headerlink" title="如何从键盘/控制台获取不同类型的变量：需要使用Scanner类"></a>如何从键盘/控制台获取不同类型的变量：需要使用Scanner类</h2><ol><li><p>导包：<code>import java.util.Scanner;</code></p></li><li><p>Scanner的实例化：<code>Scanner scan = new Scanner(System.in);</code></p></li><li><p>调用Scanner的相关方法，来获取指定类型的变量。</p></li><li><p>对于char类型的获取，Scanner没有提供相关的方法，只能获取一个字符串。</p></li><li><p>如果一定要获取char类型，可用charAt(0)获取字符串索引为0位置上的字符。</p></li></ol><ul><li>注意：需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配，则出现异常：InputMisMatchException，导致程序中断。容量小的可自动提升；</li></ul><h2 id="如何获取随机数"><a href="#如何获取随机数" class="headerlink" title="如何获取随机数"></a>如何获取随机数</h2><ol><li><code>double value = Math.random()</code>：返回一个[0.0, 1.0)之间的double型的值。</li></ol><ul><li>例：获取[a,b]之间的int型随机数：<code>(int)(Math.random() * (b - a + 1) + a)</code></li></ul><h2 id="流程控制方式结构化程序设计中规定的三种基本流程结构"><a href="#流程控制方式结构化程序设计中规定的三种基本流程结构" class="headerlink" title="流程控制方式结构化程序设计中规定的三种基本流程结构"></a>流程控制方式结构化程序设计中规定的三种基本流程结构</h2><ol><li>顺序结构</li></ol><ul><li>程序从上到下逐行执行，中间没有任何判断和跳转</li></ul><ol start="2"><li>分支结构</li></ol><ul><li>根据条件，选择性地执行某段代码</li><li>有if-else和switch-case两种分支语句</li></ul><ol start="3"><li>循环结构</li></ol><ul><li>根据循环条件，重复性地执行某段代码</li><li>有while、do…while、for三种循环语句</li><li>注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素</li></ul><h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><ol><li>if-else结构</li></ol><ul><li><p>第一种</p><p>if(条件表达式){</p><p>执行表达式</p><p>}</p></li><li><p>第二种：二选一</p><p>if(条件表达式){</p><p>执行表达式1</p><p>}else{</p><p>执行表达式2</p><p>}</p></li><li><p>第三种：多选一</p><p>if(条件表达式1){</p><p>执行表达式1</p><p>}</p><p>if(条件表达式2){</p><p>执行表达式2</p><p>}</p><p>……</p><p>else{</p><p>执行表达式n</p><p>}</p></li><li><p>使用说明</p><ul><li><p>条件表达式必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量。</p></li><li><p>语句块只有一条执行语句时，一对{}可以省略，<strong>但建议保留</strong></p></li><li><p>if-else语句结构，根据需要可以嵌套使用（一般不超过3层，超过3层未解决则停下来想其他办法）。</p></li><li><p>当if-else结构是“多选一”时，最后的else是可选的，根据需要可以省略。</p></li><li><p>当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓。</p></li><li><p>当多个条件是“包含”关系时，“小上大下 /子上父下”。</p></li><li><p>if (80 &lt; core &lt;= 99)报错原因：前面的(80 &lt; core)的结果为一个boolean类型，boolean类型不能与int类型做大小关系对比。</p></li></ul></li><li><p>针对于条件表达式：</p><ul><li><p>如果多个表达式之间是”互斥“关系（或没有交集的关系），判断和执行语句的上下顺序不影响。</p></li><li><p>如果多个表达式之间有交集的关系，则需要根据实际情况来决定哪个声明在上面。</p></li><li><p>如果多个表达式之间有包含关系，通常情况下，需要将范围小的声明在范围大的上面，否则范围小的就没机会执行了。</p></li><li><p>就近原则</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span>(y &gt; <span class="number">2</span>)</span><br><span class="line">        执行语句<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    执行语句<span class="number">2</span>;</span><br><span class="line"><span class="comment">//上述语句相当于：</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span>(y &gt; <span class="number">2</span>)</span><br><span class="line">        执行语句<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        执行语句<span class="number">2</span>;</span><br><span class="line"><span class="comment">//以上误判源于省略了单行执行语句的&#123;&#125;，所以尽量不要省略&#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ol start="2"><li>switch-case结构</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802210937.png" alt="13Switch-Case"></p><ul><li><p>说明</p><ul><li>根据switch表达式中的值，依次匹配各个case中的常量。一旦配成功，则进入相应的case结构中，调用其执行语句，当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。</li><li>break，可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构。</li><li>switch结构中的表达式，只能是如下六种数据类型之一：byte、short、char、int、枚举类型（JDK5.0新增）、String类型（JDK7.0新增）。</li><li>case之后只能声明常量，尤其不能是一个范围。</li><li>break关键字是可选的。</li><li>default：相当于if-else中的else，也是可选的，且default位置是可选的，一般还是写在末尾。</li><li>如果switch-case结构中多个case的执行语句相同，则可以考虑进行合并，即写完多行执行语句相同的case以后只写1行执行语句。</li><li>凡是可以使用switch-case的结构，都可以转换为if-else。反之，不成立。</li><li>写分支结构时，如果既可以使用if-else，又可以使用switch-case（switch中表达式的取值情况不太多），优先选择使用switch-case。原因：switch-case执行效率稍高。</li></ul></li><li><p>示例：输入日期，返回日期是那一年的第几天。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountDays</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入年份：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> year = input.nextInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n请输入月份：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> month = input.nextInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n请输入日期：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> day = input.nextInt();</span><br><span class="line">        <span class="keyword">int</span> days = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (month)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">            days += <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            days += <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            days += <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            days += <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> ((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || year % <span class="number">400</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                days += <span class="number">29</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                days += <span class="number">28</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            days += <span class="number">31</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            days += day;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n&quot;</span> + year +<span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;号是&quot;</span> + year + <span class="string">&quot;年的第&quot;</span> + days + <span class="string">&quot;天。&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;\n输入有误！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>循环结构</li></ol><ul><li><p>在某些条件满足得情况下，反复执行特定代码的功能</p></li><li><p>循环语句的四个组成部分</p><ul><li>①初始化部分（init_statement）</li><li>②循环条件部分（test_exp）–&gt;  boolean类型</li><li>③循环体部分（body_statement）</li><li>④迭代部分（alter_statement）</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802210958.png" alt="14LoopStructure"></p><ul><li><p>通常情况下，循环结束都是因为②中循环条件返回了false</p><ul><li><p>循环语句分类</p><ul><li><p>for循环</p></li><li><p>结构</p><p>for(① ;  ② ;  ④){</p><p>​        ③</p><p>}</p><p>执行过程：① -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; …… -&gt; 直到②不再返回true，跳出循环</p></li><li><p>例题：遍历100以内的偶数，输出所有偶数的和，输出所有偶数的个数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErgodicEvenNum</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">                count += <span class="number">1</span>;                        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;0-100内偶数有&quot;</span> + count + <span class="string">&quot;个，它们的和为：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i在for循环内有效，出了for循环就失效了</span></span><br></pre></td></tr></table></figure></li><li><p>例题：输入两个正整数m和n，求其最大公约数和最小公倍数。比如，12和20的最大公约数是4，最小公倍数是60。</p><ul><li>说明break的作用</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetGcdLcm</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入第一个整数：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> m = scan.nextInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;\n请输入第二个整数：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">        <span class="keyword">int</span> min = (m &lt;= n)? m : n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (m % i == <span class="number">0</span> &amp;&amp; n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;\n&quot;</span> + m + <span class="string">&quot;和&quot;</span> + n + <span class="string">&quot;的最大公约数为&quot;</span> + i + <span class="string">&quot;，&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = (m &gt;= n)? m : n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = max; i &lt;= m * n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i % m == <span class="number">0</span> &amp;&amp; i % n == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;最小公倍数为&quot;</span> + i + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>while循环</p><ul><li><p>结构</p><p><code>①初始化部分</code></p><p><code>while(②循环条件部分)&#123;</code></p><p>​    <code>③循环体部分;</code></p><p>​    <code>④迭代部分;</code></p><p><code>&#125;</code></p><p>执行过程：① -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; …… -&gt;②</p></li></ul></li><li><p>说明</p><ul><li><p>注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。</p></li><li><p>for循环和while循环可以相互转换</p><ul><li>for循环和while循环初始化条件的作用范围不同。</li></ul></li><li><p>i 出了while循环后可以继续使用，原因：①初始化部分在循环外。</p></li></ul></li><li><p>do-while</p><ul><li><p>结构</p><p><code>①</code></p><p><code>do&#123;</code></p><p><code>③；</code></p><p><code>④；</code></p><p><code>&#125;while(②)；</code></p><p>执行过程：① -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② ……     -&gt;②</p></li><li><p>特点</p><ul><li>先执行再判断，至少执行一次循环体。</li><li>开发中较少使用do-while，for和while使用较多。</li></ul></li></ul></li></ul></li></ul></li></ul><ol start="4"><li>循环语句综合题：从键盘输入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时，结束程序。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CirCom</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> posNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> negNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> alter = scan.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (alter &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                posNum += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (alter &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                negNum += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的正数个数为：&quot;</span> + posNum);</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的负数个数为：&quot;</span> + negNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>说明：</p><ul><li><p>while(true)就相当于for(;;)</p></li><li><p>结束循环的几种方式</p><ul><li>循环条件部分返回false；</li><li>在循环体中执行break。</li></ul></li></ul></li></ul><ol start="5"><li>嵌套循环</li></ol><ul><li><p>嵌套循环的使用</p><ul><li><p>嵌套循环：将一个循环结构A声明在另一个循环结构B的循环体中，就构成了嵌套循环。</p></li><li><p>外层循环：循环结构B。</p></li><li><p>内层循环：循环结构A。</p></li><li><p>说明</p><ul><li>内层循环结构遍历一遍，只相当于外层循环结构循环一次。</li><li>假设外层循环需要执行m次，内层循环需要执行n次，此时内存层循环的循环体需要执行m*n次。</li></ul></li><li><p>技巧：外层循环控制行数，内层循环控制列数。</p></li></ul></li><li><p>例题：九九乘法表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiTable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;要打印几行？（1-9）&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> line = scan.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= line; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot;x&quot;</span> + j + <span class="string">&quot;=&quot;</span> + i * j + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>100以内所有质数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriNum</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;要打印多少以内的质数？&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> limtNum = scan.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;*********结果*********&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> isPriNum = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= limtNum; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++)        &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j ==<span class="number">0</span>)&#123;</span><br><span class="line">                    isPriNum = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isPriNum)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">            isPriNum = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优化</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriNum</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;要打印多少以内的质数？&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> limtNum = scan.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;*********结果*********&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();<span class="comment">//获取当前时间距1970-01-01 00:00:00的毫秒数（long型）</span></span><br><span class="line">        <span class="keyword">boolean</span> isPriNum = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= limtNum; i++)&#123;</span><br><span class="line">            <span class="comment">//for (int j = 2; j &lt; i; j++)&#123;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= Math.sqrt(i); j++)&#123;<span class="comment">//优化二：一个数如果在2到它本身开方的范围内没有商，则为质数</span></span><br><span class="line">                <span class="keyword">if</span> (i % j ==<span class="number">0</span>)&#123;</span><br><span class="line">                    isPriNum = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//优化一：只对本身非质数的自然数是有效的。加break前后对比：20181ms/2174ms = 9.28</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isPriNum)&#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isPriNum = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;质数的个数：&quot;</span> + count);</span><br><span class="line">        System.out.println(<span class="string">&quot;所花费的时间：&quot;</span> + (start - end));</span><br><span class="line">        <span class="comment">//优化前：17916ms 优化一：1629ms 优化二：16ms</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="6"><li>特殊关键字的使用</li></ol><ul><li><p>break</p><ul><li>使用范围：switch-case、循环结构中</li><li>循环中使用的作用：结束当前循环</li><li>默认跳出包裹此关键字最近的一层循环</li><li>结束指定标识的一层循环结构</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label:<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (j % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span> label;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>continue</p><ul><li><p>使用范围：循环结构中</p></li><li><p>循环中使用的作用：结束当次循环</p></li><li><p>结束指定标识的一层循环结构的当次循环</p><p><code>countinue label;  </code></p></li></ul></li><li><p>相同点：两个关键字后面不能声明执行语句</p></li><li><p>return</p><ul><li>并非专门用于结束循环的，它的的功能是结束一个方法。当一个方法执行到一个return时，这个方法将被结束。</li><li>与break、continue不同的是吗，return直接结束整个方法，不管这个return处于多少层循环之内。</li></ul></li><li><p>补充：衡量一个功能代码的优劣</p><ul><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效率与低存储：时间复杂度、空间复杂度（衡量算法的好坏）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章Java语言概述</title>
      <link href="/2020/08/02/%E7%AC%AC1%E7%AB%A0Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/"/>
      <url>/2020/08/02/%E7%AC%AC1%E7%AB%A0Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><ol><li><p>//单行注释</p></li><li><p>/*多行注释*/</p></li><li><p>/**文档注释（Java特有）*/</p></li></ol><h2 id="单行和多行注释的作用"><a href="#单行和多行注释的作用" class="headerlink" title="单行和多行注释的作用"></a>单行和多行注释的作用</h2><ol><li><p>对所写程序进行解释说明，增强可读性，方便自己和别人。</p></li><li><p>调试所写代码（注释掉不需要运行部分）。</p></li><li><p>特点：单行和多行注释掉的内容不参与编译，编译以后生成的.class文件中不包含注释掉的信息。</p></li></ol><h2 id="文档注释的使用"><a href="#文档注释的使用" class="headerlink" title="文档注释的使用"></a>文档注释的使用</h2><ol><li><p>注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。</p></li><li><p>操作方式</p><ul><li>&gt;javadoc -d [生成文件名] -author -version [解析文件名.java]（-author和-version分别为注释当中@author和@version后面的内容）</li></ul></li></ol><ul><li><strong>注意：多行注释不能嵌套使用</strong></li></ul><h2 id="第1个Java代码"><a href="#第1个Java代码" class="headerlink" title="第1个Java代码"></a>第1个Java代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;<span class="comment">//arguments参数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World !&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="对第一个Java程序总结"><a href="#对第一个Java程序总结" class="headerlink" title="对第一个Java程序总结"></a>对第一个Java程序总结</h3><ol><li><p>java程序的编写-编译-运行的过程</p><ul><li><p>编写：我们将编写的java代码保存在以“.java”结尾的源文件中</p></li><li><p>编译：使用javac.exe来编译我们的java源文件。格式：javac 源文件名.java</p></li><li><p>运行：使用java.exe解释运行我们的字节码文件（.class)。格式：java 类名</p></li></ul></li><li><p>在一个java源文件中可以声明多个类（class），但是只能有一个类声明为public的，而且要求声明为public的类的类名必须与源文件名必须相同。</p></li><li><p>程序的入口是main()方法，格式是固定的。可以写成：public     static void main(String[] args)或public static void main(String[] a)或public     static void main(String a[])</p></li><li><p>输出语句</p><ul><li><p>System.out.println()：输出后换行，无内容则只换行</p></li><li><p>System.out.print()：输出后不换行</p></li></ul></li><li><p>每一个执行语句都以分号结尾，每个执行语句只要以分号隔开即使不换行也不影响执行</p></li><li><p>编译的过程：编译以后，会生成一个或多个字节码文件，字节码文件与java源文件中的类名相同。</p></li></ol><hr><h2 id="章节练习"><a href="#章节练习" class="headerlink" title="章节练习"></a>章节练习</h2><ol><li><p>java语言的特点是什么？</p><ul><li>面向对象性：两个基本概念：类、对象；三大特性：封装、继承、多态</li><li>健壮性：吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制</li><li>跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write      once , Run Anywhere”</li></ul></li><li><p>System.out.println()和System.out.print()有什么区别？</p><ul><li>前者输出内容后换行，后者输出后不换行。</li></ul></li><li><p>一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</p><ul><li>答：可以。但最多只有一个类名声明为public，与文件名相同。</li></ul></li><li><p>设置path的目的是什么？</p><ul><li>目的是为了在控制台的任何文件路径下，都可以调用jdk指定目录下的所有指令。</li></ul></li><li><p>JDK,JRE和JVM的关系是什么？以及JDK、JRE包含的主要结构有哪些？</p><ul><li>关系：JDK包含JRE，JRE包含JVM</li><li>JDK = JRE + Java开发工具（javac.exe、java.exe、javadoc.exe）</li><li>JRD = JVM + Java核心类库</li></ul></li><li><p>创建如下类，使得运行可以输出：<img src="/2020/08/02/%E7%AC%AC1%E7%AB%A0Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/01RunOutput" alt="01RunOutput"></p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChairMan</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：习大大\n&quot;</span>);</span><br><span class="line">        <span class="comment">//System.out.println();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;性别：男&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;住址：北京中南海&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><p>编译和运行上述代码的指令</p><ul><li><p>编译：&gt;javac ChairMan.java</p></li><li><p>运行：&gt;java ChairMan</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前言Preface</title>
      <link href="/2020/08/02/%E5%89%8D%E8%A8%80Preface/"/>
      <url>/2020/08/02/%E5%89%8D%E8%A8%80Preface/</url>
      
        <content type="html"><![CDATA[<h1 id="博客指南"><a href="#博客指南" class="headerlink" title="博客指南"></a>博客指南</h1><h2 id="入坑"><a href="#入坑" class="headerlink" title="入坑"></a>入坑</h2><ul><li>首先感谢酷安<a href="http://www.coolapk.com/u/2292833">@加加加加油呦</a>、<a href="http://www.coolapk.com/u/2292833">@硝酸银</a>、<a href="http://www.coolapk.com/u/796912">lhspang</a>三位老哥的推荐让我入坑了个人博客，过程确实没少折腾（纯小白，完全从0开始:sob:)，图床搭建，仓库创建，网站主题配置每一步都遇到过不少问题，其中图床搭建和主题配置（修改那个yml文件）最磨人，但是搭建好了以后是真的香，从此以后我也是一个由自己的网站的人了:sunglasses:。</li></ul><h2 id="主体内容"><a href="#主体内容" class="headerlink" title="主体内容"></a>主体内容</h2><ul><li><p>由于目前在自学Java，所以这个博客主要用来放我的Java笔记（后续也许会写一些其他教程），各位如果感兴趣或者想借鉴一下的话直接点网站右边标签里面那个Java就只显示Java的笔记了。如图</p><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802144156.png" alt="image-20200802144156706"></p><p><strong>（手机端的标签在页面下方）</strong></p><p>我目前使用的Java教程是B站的<a href="https://www.bilibili.com/video/BV1zE41197bw?from=search&seid=18257695344041836043">【尚硅谷】 Java全栈工程师就业班 全套（1100小时完结）</a>，有兴趣的老哥（or小姐姐）可以一起学习啊:happy:，做云同学:smirk:。​然后包括教学视频在内的各种课程配套资料可以去尚硅谷的微信公号回复Java获取，由于B站是别人整理拼接的，有部分教学视频缺失，所以建议保存他们的公众号给的度盘资源，然后对应着去看相应缺失的部分，看完再回B站就好了（为啥对B战这么执着:fun_moon_with_face:？当然是因为没有弹幕坚持不下去:cry:加上度盘没会员，画质太渣）</p></li></ul><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul><li><p>这是对应的学习资料</p><p>链接：<a href="https://pan.baidu.com/s/15ocrWsdcODC8kA1VCkMaXQ">https://pan.baidu.com/s/15ocrWsdcODC8kA1VCkMaXQ</a><br>提取码：57vp </p><p><font color="purple"><strong>注意：如果链接失效了就自己去尚硅谷微信公众号回复关键字获取</strong></font></p></li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li>博客搭建：<a href="https://hexo.io/zh-cn/">Hexo</a> + <a href="https://github.com/">GitHub</a> + <a href="https://git-scm.com/">Git</a> + <a href="https://nodejs.org/en/download/">Node.js</a></li><li>图床：<a href="https://github.com/Molunerfinn/PicGo">PicGo</a> + <a href="https://github.com/">GitHub</a></li><li>博客主题：<a href="https://demo.jerryc.me/">butterfly</a></li><li>参考文章：<a href="https://spoience.com/hexo-github-build.html#%E5%89%8D%E8%A8%80">https://spoience.com/hexo-github-build.html#%E5%89%8D%E8%A8%80</a></li></ul><h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><ul><li>点击右下方的小齿轮可打开设置，即可进行切换阅读模式开关、日/夜间模式切换、网页的放大/缩小等操作，下方箭头为回到顶部。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802152208.png" alt="image-20200802152207947"></p><ul><li>手机端会在齿轮与回到顶部之间多一个目录按钮。</li></ul><blockquote><p>按钮操作均来自butterfly主题自带。</p></blockquote><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><ul><li>最后附上两张酷安老哥身份标识图：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802145953.png" alt="Coolapk受虐滑稽"><img src="https://cdn.jsdelivr.net/gh/Triabin/MyImgBed@master/20200802150009.png" alt="Coolapk牛啤"></p><hr><p><strong><font color="red">后续网页各方面有变动都会在这个网页里面更新，网页我会置顶。</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> Article </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Preface </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
